<!DOCTYPE html>
<html lang="en">
<head>
    <script defer src="https://analytics.baloneys.studio/script.js" data-website-id="03418d76-12f0-4a2b-94ba-24dff73a6f6b"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris - baloneys</title>
    <link rel="shortcut icon" href="https://kanaris-beans.com/public/pw64s5dmavz539gvjm065tw71xp1.png" type="icon/png" sizes="32x32">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
            font-family: 'Inter', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .navigation-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .navigation-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .navigation-logo {
            text-decoration: none;
            color: #6366f1;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .navigation-desktop-menu {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .navigation-link {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .navigation-link:hover {
            color: #ffffff;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #6366f1;
            color: white;
        }

        .btn-primary:hover {
            background: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .navigation-toggle {
            display: none;
            background: none;
            border: none;
            color: #ffffff;
            cursor: pointer;
            padding: 0.5rem;
        }

        .main-wrapper {
            flex: 1 0 auto;
            padding-top: 80px;
            padding-bottom: 100px;
        }

        .main-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .page-header {
            text-align: center;
            margin-bottom: 3rem;
            padding-top: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #818cf8 0%, #6366f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .page-subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
        }

        .game-container {
            background: #1a1a1a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            margin: 0 auto 100px auto;
        }

        .menu {
            text-align: center;
            margin-bottom: 20px;
        }

        .menu h2 {
            color: #6366f1;
            margin-bottom: 30px;
        }

        .menu-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: #6366f1;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }

        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .lobby-input, select {
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            padding: 10px 15px;
            font-size: 1em;
            border-radius: 8px;
            margin: 0 10px;
            min-width: 200px;
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 2px;
        }

        select {
            cursor: pointer;
            width: 100%;
            max-width: 400px;
            margin: 10px auto;
            display: block;
        }

        .lobby-input:focus, select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
        }

        .status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }

        .status.waiting {
            background: rgba(255, 165, 0, 0.2);
            color: #ffa500;
            border: 1px solid #ffa500;
        }

        .status.connected {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid #00ff00;
        }

        .status.error {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4444;
            border: 1px solid #ff4444;
        }

        .lobby-code-display {
            font-size: 1.5em;
            color: #6366f1;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 3px;
            margin: 10px 0;
            padding: 15px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 8px;
            border: 2px dashed #6366f1;
        }

        .hidden {
            display: none !important;
        }
        
        #gameArea {
            position: relative;
        }

        .tetris-arena {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .game-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .next-pieces-panel {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        #gameArea.online-mode .next-pieces-panel {
            display: none !important;
        }
        
        .next-piece-bottom {
            display: none;
            margin-top: 10px;
            text-align: center;
        }
        
        #gameArea.online-mode .next-piece-bottom {
            display: block;
        }

        .next-pieces-title {
            font-size: 0.75rem;
            color: #6366f1;
            font-weight: 600;
            text-align: center;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .next-piece-preview {
            width: 50px;
            height: 50px;
            background: #000;
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .skin-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .skin-arrow {
            background: #6366f1;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 1rem;
            padding: 0;
        }

        .skin-arrow:hover {
            background: #4f46e5;
            transform: scale(1.1);
        }

        .skin-arrow:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .skin-preview {
            width: 80px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .skin-preview.selected {
            border-color: #10b981;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }

        .skin-preview:hover {
            border-color: #6366f1;
            transform: scale(1.05);
        }

        .loss-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: #ff4444;
            text-shadow: 0 0 20px #ff4444, 0 0 40px #ff4444, 0 0 60px #ff4444;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 16px;
            border: 3px solid #ff4444;
            z-index: 999;
            animation: pulseGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulseGlow {
            from {
                text-shadow: 0 0 20px #ff4444, 0 0 40px #ff4444, 0 0 60px #ff4444;
                box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            }
            to {
                text-shadow: 0 0 30px #ff4444, 0 0 50px #ff4444, 0 0 80px #ff4444;
                box-shadow: 0 0 40px rgba(255, 68, 68, 0.8);
            }
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .player-info {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 250px;
        }

        .player-name {
            font-size: 1.5rem;
            font-weight: 700;
            color: #6366f1;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .player-score {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .player-score strong {
            color: rgba(255, 255, 255, 0.6);
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-score span {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .player-score.losses-display {
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        .player-score.losses-display span {
            color: #ff4444;
        }

        .tetris-canvas {
            border: 3px solid #6366f1;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
            background: #000;
        }

        .footer-root {
            flex-shrink: 0;
            width: 100%;
            background: #1a1a1a;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .footer-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 2rem 1.5rem;
        }

        .footer-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr 1fr;
            gap: 3rem;
            margin-bottom: 2rem;
        }

        .footer-brand-column {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .footer-logo-text {
            font-size: 1.5rem;
            font-weight: 700;
            color: #6366f1;
        }

        .footer-brand-description {
            font-size: 0.95rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.7);
            max-width: 300px;
        }

        .footer-social-links {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .footer-social-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(99, 102, 241, 0.2);
            color: rgba(255, 255, 255, 0.8);
            transition: all 0.3s;
        }

        .footer-social-icon:hover {
            background: rgba(99, 102, 241, 0.3);
            color: #fff;
            transform: translateY(-2px);
        }

        .footer-nav-column {
            display: flex;
            flex-direction: column;
        }

        .footer-column-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #fff;
        }

        .footer-nav-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .footer-nav-link {
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s;
            text-decoration: none;
        }

        .footer-nav-link:hover {
            color: #fff;
        }

        .footer-bottom {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .footer-copyright {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.6);
        }

        @media(max-width: 767px) {
            .navigation-desktop-menu {
                display: none;
            }
            
            .navigation-toggle {
                display: flex;
            }

            .footer-grid {
                grid-template-columns: 1fr;
            }

            .main-content {
                padding: 1rem;
            }

            .tetris-arena {
                gap: 15px;
            }

            .tetris-canvas {
                width: 100%;
                max-width: 200px;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <nav class="navigation-wrapper">
        <div class="navigation-container">
            <a href="../index.html" class="navigation-logo">baloneys</a>
            <div class="navigation-desktop-menu">
                <a href="../index.html" class="navigation-link">Home</a>
                <a href="https://vrchat.com/home/user/usr_54097a4a-dab6-47ce-bcc5-00f39aa03555" target="_blank" class="navigation-link">Worlds</a>
                <a href="vrc-dynamic-player-tags.html" class="navigation-link">Tagging</a>
                <a href="https://jinxxy.com/baloneys" target="_blank" class="navigation-link">Store</a>
                <a href="https://discord.gg/gYWJsYhwXN" target="_blank" class="btn-sm btn-primary btn">Contact Me</a>
            </div>
            <button id="navToggle" aria-label="Open Menu" class="navigation-toggle">
                <svg width="24" height="24" viewBox="0 0 24 24">
                    <path d="M4 6h16M4 12h16M4 18h16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </button>
        </div>
    </nav>

    <div class="main-wrapper">
        <div class="main-content">
            <header class="page-header">
                <h1>Tetris</h1>
                <p class="page-subtitle">falling blocks killed my family</p>
            </header>

            <div class="game-container">
                <div id="menu" class="menu">
                    <h2>Select Game Mode</h2>
                    <div class="menu-buttons">
                        <button onclick="startLocalGame()">üéÆ Local Multiplayer</button>
                        <button onclick="showOnlineMenu()">üåê Online Multiplayer</button>
                    </div>
                </div>

                <div id="settingsMenu" class="menu hidden">
                    <h2>Game Settings</h2>
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">Player Names:</label>
                        <input type="text" id="player1NameInput" class="lobby-input" placeholder="Player 1 Name" maxlength="15" style="display: block; margin: 10px auto;">
                        <input type="text" id="player2NameInput" class="lobby-input" placeholder="Player 2 Name" maxlength="15" style="display: block; margin: 10px auto;">
                    </div>
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">Game Mode:</label>
                        <select id="maxLosses">
                            <option value="3">Best of 3 (First to 3 losses loses)</option>
                            <option value="5">Best of 5 (First to 5 losses loses)</option>
                            <option value="10">Best of 10 (First to 10 losses loses)</option>
                            <option value="infinite">Infinite Mode (Never ends)</option>
                        </select>
                        <p style="font-size: 0.85em; color: rgba(255, 255, 255, 0.6); margin-top: 15px;">
                            Topping out costs 1000 points and clears your board.<br>
                            Game continues until max losses reached.
                        </p>
                    </div>
                    <div class="menu-buttons">
                        <button onclick="proceedToGame()">Start Game</button>
                        <button onclick="backToMainMenu()" style="background: #555;">‚Üê Back</button>
                    </div>
                </div>

                <div id="onlineMenu" class="menu hidden">
                    <h2>Online Multiplayer</h2>
                    <p style="font-size: 0.9em; color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                        Play with 2-4 players online!
                    </p>
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">Your Name:</label>
                        <input type="text" id="onlinePlayerName" class="lobby-input" placeholder="Enter Your Name" maxlength="15" style="display: block; margin: 10px auto;">
                    </div>
                    <div class="menu-buttons">
                        <button onclick="createLobby()">‚ûï Create Lobby</button>
                    </div>
                    <div style="margin: 20px 0;">
                        <input type="text" id="joinCode" class="lobby-input" placeholder="Enter Lobby Code" maxlength="6">
                        <button onclick="joinLobby()">üö™ Join Lobby</button>
                    </div>
                    <p style="font-size: 0.85em; color: rgba(255, 255, 255, 0.5); margin: 15px 0; text-align: center;">
                        <em>Note: If multiplayer doesn't work, it may be due to WebRTC incompatibility.</em>
                    </p>
                    <button onclick="backToMainMenuFromOnline()" style="background: #555; margin-top: 10px;">‚Üê Back</button>
                </div>

                <div id="lobbyWaiting" class="hidden">
                    <div class="status waiting">
                        <p>Waiting for players to join...</p>
                        <p class="lobby-code-display">Lobby Code: <span id="lobbyCodeDisplay"></span></p>
                        <p style="font-size: 0.9em; margin-top: 10px;" id="lobbyStatus">Waiting for players... (2-4 players)</p>
                    </div>
                    <button onclick="cancelLobby()" style="background: #ff4444; margin-top: 15px;">Cancel</button>
                </div>

                <div id="readyScreen" class="hidden">
                    <div class="status waiting">
                        <h2 style="color: #6366f1; margin-bottom: 20px;">Get Ready!</h2>
                        <div style="margin-bottom: 20px;">
                            <p id="p1ReadyStatus" style="margin: 10px 0; font-size: 1.2rem;">
                                0/0 players ready
                            </p>
                            <p id="p2ReadyStatus" style="margin: 10px 0; font-size: 0.9rem; color: rgba(255, 255, 255, 0.6);">
                                Waiting for all players to ready up...
                            </p>
                        </div>
                        <button id="readyButton" onclick="toggleReady()">Ready Up!</button>
                        <button onclick="cancelLobby()" style="background: #ff4444; margin-top: 15px;">Cancel</button>
                    </div>
                </div>

                <div id="statusMessage" class="status hidden"></div>

                <div id="gameArea" class="hidden">
                    <div id="spectatorCounter" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2); display: none;">
                        <span style="color: rgba(255, 255, 255, 0.7); font-size: 0.9rem;">üëÅÔ∏è Spectators: </span>
                        <span id="spectatorCount" style="color: #6366f1; font-weight: 700; font-size: 1rem;">0</span>
                    </div>
                    <div id="tetrisAnnouncement" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 30px 50px; border-radius: 16px; border: 3px solid #fff; box-shadow: 0 0 30px rgba(99, 102, 241, 0.8); display: none; z-index: 1000; animation: pulse 0.5s ease-in-out;">
                        <div style="font-size: 2.5rem; font-weight: 900; color: #fff; text-align: center; text-shadow: 0 0 10px rgba(0,0,0,0.5);">üéâ TETRIS! üéâ</div>
                        <div id="tetrisPlayerName" style="font-size: 1.5rem; font-weight: 700; color: #fbbf24; text-align: center; margin-top: 10px;"></div>
                    </div>
                    <div class="tetris-arena">
                        <div class="player-area">
                            <div class="player-info">
                                <div class="player-name" id="playerName1">Player 1</div>
                                <div class="player-score">
                                    <strong>Score</strong>
                                    <span id="score1">0</span>
                                </div>
                                <div class="player-score losses-display">
                                    <strong>Losses</strong>
                                    <span id="losses1">0</span>
                                </div>
                            </div>
                            <div class="game-row">
                                <div class="next-pieces-panel">
                                    <div class="next-pieces-title">Next</div>
                                    <canvas class="next-piece-preview" id="next1-0" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next1-1" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next1-2" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next1-3" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next1-4" width="50" height="50"></canvas>
                                </div>
                                <canvas id="canvas1" class="tetris-canvas" width="200" height="400"></canvas>
                            </div>
                            <div class="skin-carousel">
                                <button class="skin-arrow" onclick="changeSkin(1, -1)">‚Äπ</button>
                                <div class="skin-preview" id="skinPreview1" onclick="showSkinSelector(1)"></div>
                                <button class="skin-arrow" onclick="changeSkin(1, 1)">‚Ä∫</button>
                            </div>
                            <div class="next-piece-bottom">
                                <div style="font-size: 0.75rem; color: #6366f1; font-weight: 600; margin-bottom: 5px;">NEXT</div>
                                <canvas id="nextBottom1" width="50" height="50" style="border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; background: #000;"></canvas>
                            </div>
                        </div>
                        <div class="player-area">
                            <div class="player-info">
                                <div class="player-name" id="playerName2">Player 2</div>
                                <div class="player-score">
                                    <strong>Score</strong>
                                    <span id="score2">0</span>
                                </div>
                                <div class="player-score losses-display">
                                    <strong>Losses</strong>
                                    <span id="losses2">0</span>
                                </div>
                            </div>
                            <div class="game-row">
                                <canvas id="canvas2" class="tetris-canvas" width="200" height="400"></canvas>
                                <div class="next-pieces-panel">
                                    <div class="next-pieces-title">Next</div>
                                    <canvas class="next-piece-preview" id="next2-0" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next2-1" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next2-2" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next2-3" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next2-4" width="50" height="50"></canvas>
                                </div>
                            </div>
                            <div class="skin-carousel">
                                <button class="skin-arrow" onclick="changeSkin(2, -1)">‚Äπ</button>
                                <div class="skin-preview" id="skinPreview2" onclick="showSkinSelector(2)"></div>
                                <button class="skin-arrow" onclick="changeSkin(2, 1)">‚Ä∫</button>
                            </div>
                            <div class="next-piece-bottom">
                                <div style="font-size: 0.75rem; color: #6366f1; font-weight: 600; margin-bottom: 5px;">NEXT</div>
                                <canvas id="nextBottom2" width="50" height="50" style="border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; background: #000;"></canvas>
                            </div>
                        </div>
                        <div class="player-area player-area-3 hidden">
                            <div class="player-info">
                                <div class="player-name" id="playerName3">Player 3</div>
                                <div class="player-score">
                                    <strong>Score</strong>
                                    <span id="score3">0</span>
                                </div>
                                <div class="player-score losses-display">
                                    <strong>Losses</strong>
                                    <span id="losses3">0</span>
                                </div>
                            </div>
                            <div class="game-row">
                                <div class="next-pieces-panel">
                                    <div class="next-pieces-title">Next</div>
                                    <canvas class="next-piece-preview" id="next3-0" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next3-1" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next3-2" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next3-3" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next3-4" width="50" height="50"></canvas>
                                </div>
                                <canvas id="canvas3" class="tetris-canvas" width="200" height="400"></canvas>
                            </div>
                            <div class="skin-carousel">
                                <button class="skin-arrow" onclick="changeSkin(3, -1)">‚Äπ</button>
                                <div class="skin-preview" id="skinPreview3" onclick="showSkinSelector(3)"></div>
                                <button class="skin-arrow" onclick="changeSkin(3, 1)">‚Ä∫</button>
                            </div>
                            <div class="next-piece-bottom">
                                <div style="font-size: 0.75rem; color: #6366f1; font-weight: 600; margin-bottom: 5px;">NEXT</div>
                                <canvas id="nextBottom3" width="50" height="50" style="border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; background: #000;"></canvas>
                            </div>
                        </div>
                        <div class="player-area player-area-4 hidden">
                            <div class="player-info">
                                <div class="player-name" id="playerName4">Player 4</div>
                                <div class="player-score">
                                    <strong>Score</strong>
                                    <span id="score4">0</span>
                                </div>
                                <div class="player-score losses-display">
                                    <strong>Losses</strong>
                                    <span id="losses4">0</span>
                                </div>
                            </div>
                            <div class="game-row">
                                <canvas id="canvas4" class="tetris-canvas" width="200" height="400"></canvas>
                                <div class="next-pieces-panel">
                                    <div class="next-pieces-title">Next</div>
                                    <canvas class="next-piece-preview" id="next4-0" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next4-1" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next4-2" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next4-3" width="50" height="50"></canvas>
                                    <canvas class="next-piece-preview" id="next4-4" width="50" height="50"></canvas>
                                </div>
                            </div>
                            <div class="skin-carousel">
                                <button class="skin-arrow" onclick="changeSkin(4, -1)">‚Äπ</button>
                                <div class="skin-preview" id="skinPreview4" onclick="showSkinSelector(4)"></div>
                                <button class="skin-arrow" onclick="changeSkin(4, 1)">‚Ä∫</button>
                            </div>
                            <div class="next-piece-bottom">
                                <div style="font-size: 0.75rem; color: #6366f1; font-weight: 600; margin-bottom: 5px;">NEXT</div>
                                <canvas id="nextBottom4" width="50" height="50" style="border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 4px; background: #000;"></canvas>
                            </div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 10px;" id="controlsText">
                            <strong>Player 1:</strong> WASD (W=rotate, A=left, S=soft drop, D=right, Q=hard drop)<br>
                            <strong>Player 2:</strong> Arrow keys (‚Üë=rotate, ‚Üê=left, ‚Üì=soft drop, ‚Üí=right, Space=hard drop)
                        </p>
                        <button onclick="endGame()" style="background: #ff4444;">End Game</button>
                    </div>
                </div>

                <div id="gameOverScreen" class="menu hidden">
                    <h2 style="color: #6366f1;">Game Over!</h2>
                    <div style="margin: 30px 0; font-size: 1.5rem;">
                        <p id="winnerText" style="color: #10b981; font-weight: bold; margin-bottom: 20px;"></p>
                        <p style="font-size: 1.2rem; color: rgba(255, 255, 255, 0.9);" id="finalScores"></p>
                    </div>
                    <button onclick="endGame()">Back to Menu</button>
                </div>
            </div>
        </div>
    </div>

    <footer class="footer-root">
        <div class="footer-container">
            <div class="footer-grid">
                <div class="footer-brand-column">
                    <a href="../index.html">
                        <span class="footer-logo-text">baloneys</span>
                    </a>
                    <p class="footer-brand-description">
                        Crafting highly immersive experiences,<br>
                        environments, and robust prefabs.
                    </p>
                    <div class="footer-social-links">
                        <a href="https://discord.gg/gYWJsYhwXN" target="_blank">
                            <div class="footer-social-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24">
                                    <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M8 12a1 1 0 1 0 2 0a1 1 0 0 0-2 0m6 0a1 1 0 1 0 2 0a1 1 0 0 0-2 0"></path>
                                        <path d="M15.5 17c0 1 1.5 3 2 3c1.5 0 2.833-1.667 3.5-3c.667-1.667.5-5.833-1.5-11.5c-1.457-1.015-3-1.34-4.5-1.5l-.972 1.923a11.9 11.9 0 0 0-4.053 0L9 4c-1.5.16-3.043.485-4.5 1.5c-2 5.667-2.167 9.833-1.5 11.5c.667 1.333 2 3 3.5 3c.5 0 2-2 2-3"></path>
                                        <path d="M7 16.5c3.5 1 6.5 1 10 0"></path>
                                    </g>
                                </svg>
                            </div>
                        </a>
                        <a href="https://x.com/beilude" target="_blank">
                            <div class="footer-social-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24">
                                    <path d="M22 4.01c-1 .49-1.98.689-3 .99c-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4c0 0-4.182 7.433 4 11c-1.872 1.247-3.739 2.088-6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58-1.04 6.522-3.723 7.651-7.742a13.8 13.8 0 0 0 .497-3.753c0-.249 1.51-2.772 1.818-4.013z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                                </svg>
                            </div>
                        </a>
                        <a href="https://github.com/baloneys" target="_blank">
                            <div class="footer-social-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24">
                                    <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5c.08-1.25-.27-2.48-1-3.5c.28-1.15.28-2.35 0-3.5c0 0-1 0-3 1.5c-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.4 5.4 0 0 0 4 9c0 3.5 3 5.5 6 5.5c-.39.49-.68 1.05-.85 1.65S8.93 17.38 9 18v4"></path>
                                        <path d="M9 18c-4.51 2-5-2-7-2"></path>
                                    </g>
                                </svg>
                            </div>
                        </a>
                    </div>
                </div>
                <div class="footer-nav-column">
                    <h3 class="footer-column-title">Navigation</h3>
                    <nav class="footer-nav-list">
                        <a href="../index.html" class="footer-nav-link">Home</a>
                        <a href="https://jinxxy.com/baloneys" target="_blank" class="footer-nav-link">Jinxxy Store</a>
                        <a href="https://vrchat.com/home/user/usr_54097a4a-dab6-47ce-bcc5-00f39aa03555" target="_blank" class="footer-nav-link">VRChat Worlds</a>
                        <a href="vrc-dynamic-player-tags.html" class="footer-nav-link">VRCDynamicPlayerTags</a>
                    </nav>
                </div>
                <div class="footer-nav-column">
                    <h3 class="footer-column-title">Resources</h3>
                    <nav class="footer-nav-list">
                        <a href="https://discord.gg/gYWJsYhwXN" target="_blank" class="footer-nav-link">Support Discord</a>
                        <a href="https://kanaris-beans.com/terms" target="_blank" class="footer-nav-link">Terms of Service</a>
                        <a href="https://kanaris-beans.com/privacy" target="_blank" class="footer-nav-link">Privacy Policy</a>
                    </nav>
                </div>
            </div>
            <div class="footer-bottom">
                <p class="footer-copyright">¬© 2025 baloneys. All rights reserved</p>
            </div>
        </div>
    </footer>

    <script>
        console.log('=== TETRIS SCRIPT LOADING ===');
        console.log('PeerJS available:', typeof Peer !== 'undefined');
        
        // Test if functions can be called
        window.addEventListener('load', () => {
            console.log('Page loaded');
            console.log('joinLobby function exists:', typeof joinLobby === 'function');
            console.log('createLobby function exists:', typeof createLobby === 'function');
            console.log('startLocalGame function exists:', typeof startLocalGame === 'function');
        });
        
        // Navigation
        const navToggle = document.getElementById('navToggle');
        navToggle?.addEventListener('click', () => {
            alert('Mobile menu not implemented in this version');
        });

        // Tetris constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20;
        
        // Gradient color schemes
        const COLOR_SCHEMES = [
            {
                name: 'Purple Dream',
                colors: [] // Will be generated as gradient
            },
            {
                name: 'Ocean Blue',
                colors: []
            },
            {
                name: 'Fire Red',
                colors: []
            },
            {
                name: 'Forest Green',
                colors: []
            },
            {
                name: 'Sunset Orange',
                colors: []
            }
        ];

        // Generate gradient colors for each scheme
        function generateGradientColors(schemeIndex) {
            const schemes = [
                { bottom: '#1e1b4b', top: '#818cf8' }, // Purple Dream
                { bottom: '#0c4a6e', top: '#38bdf8' }, // Ocean Blue
                { bottom: '#7f1d1d', top: '#f87171' }, // Fire Red
                { bottom: '#14532d', top: '#4ade80' }, // Forest Green
                { bottom: '#7c2d12', top: '#fb923c' }  // Sunset Orange
            ];
            
            const scheme = schemes[schemeIndex];
            const colors = [null]; // First color is always null
            
            for (let i = 1; i <= 7; i++) {
                const ratio = i / 7;
                colors.push(interpolateColor(scheme.bottom, scheme.top, ratio));
            }
            
            return colors;
        }

        function interpolateColor(color1, color2, ratio) {
            const hex = (x) => {
                const h = parseInt(x, 16);
                return h;
            };
            
            const r1 = hex(color1.substr(1, 2));
            const g1 = hex(color1.substr(3, 2));
            const b1 = hex(color1.substr(5, 2));
            
            const r2 = hex(color2.substr(1, 2));
            const g2 = hex(color2.substr(3, 2));
            const b2 = hex(color2.substr(5, 2));
            
            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Initialize color schemes
        for (let i = 0; i < COLOR_SCHEMES.length; i++) {
            COLOR_SCHEMES[i].colors = generateGradientColors(i);
        }

        const SHAPES = [
            [],
            [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
            [[2,2], [2,2]], // O
            [[0,3,0], [3,3,3], [0,0,0]], // T
            [[0,4,4], [4,4,0], [0,0,0]], // S
            [[5,5,0], [0,5,5], [0,0,0]], // Z
            [[6,0,0], [6,6,6], [0,0,0]], // J
            [[0,0,7], [7,7,7], [0,0,0]], // L
        ];

        // Game variables
        // Player limits: Local = 2 players only, Online = 2-4 players
        let gameMode = null;
        let gameRunning = false;
        let animationId = null;
        let peer = null;
        let connections = []; // Array of all peer connections
        let isHost = false;
        let lobbyCode = null;
        let readyPlayers = {}; // Track which players are ready
        let myPlayerId = null;
        let playerNames = {}; // Map player IDs to names
        let maxLosses = 3;
        let player1Name = 'Player 1';
        let player2Name = 'Player 2';
        let connectedPlayers = 0;
        let maxPlayers = 4; // Maximum for online multiplayer
        let spectators = []; // Array of spectator objects {peerId, name}

        const players = {
            1: {
                canvas: null,
                ctx: null,
                board: null,
                piece: null,
                nextPieces: [],
                score: 0,
                losses: 0,
                dropCounter: 0,
                dropInterval: 1000,
                lastTime: 0,
                skinIndex: 0,
                flipped: false,
                peerId: null,
                active: false
            },
            2: {
                canvas: null,
                ctx: null,
                board: null,
                piece: null,
                nextPieces: [],
                score: 0,
                losses: 0,
                dropCounter: 0,
                dropInterval: 1000,
                lastTime: 0,
                skinIndex: 0,
                flipped: true,
                peerId: null,
                active: false
            },
            3: {
                canvas: null,
                ctx: null,
                board: null,
                piece: null,
                nextPieces: [],
                score: 0,
                losses: 0,
                dropCounter: 0,
                dropInterval: 1000,
                lastTime: 0,
                skinIndex: 0,
                flipped: false,
                peerId: null,
                active: false
            },
            4: {
                canvas: null,
                ctx: null,
                board: null,
                piece: null,
                nextPieces: [],
                score: 0,
                losses: 0,
                dropCounter: 0,
                dropInterval: 1000,
                lastTime: 0,
                skinIndex: 0,
                flipped: true,
                peerId: null,
                active: false
            }
        };

        const keys = {};
        document.addEventListener('keydown', (e) => { 
            keys[e.key] = true;
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.key] = false; });

        // Helper functions
        function createBoard() {
            const board = [];
            for (let r = 0; r < ROWS; r++) {
                board.push(Array(COLS).fill(0));
            }
            return board;
        }

        function createPiece() {
            const type = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            return {
                shape: SHAPES[type],
                x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
                y: 0,
                type: type
            };
        }

        function fillNextPiecesQueue(player) {
            while (player.nextPieces.length < 5) {
                player.nextPieces.push(createPiece());
            }
        }

        function getNextPiece(player) {
            if (player.nextPieces.length === 0) {
                fillNextPiecesQueue(player);
            }
            const piece = player.nextPieces.shift();
            fillNextPiecesQueue(player);
            piece.x = Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2);
            piece.y = 0;
            return piece;
        }

        function getBlockColor(player, type, y) {
            const colors = COLOR_SCHEMES[player.skinIndex].colors;
            let baseColor = colors[type];
            
            if (!baseColor) return null;
            
            // Apply gradient based on y position
            const gradientRatio = player.flipped ? (y / ROWS) : (1 - y / ROWS);
            const schemes = [
                { bottom: '#1e1b4b', top: '#818cf8' },
                { bottom: '#0c4a6e', top: '#38bdf8' },
                { bottom: '#7f1d1d', top: '#f87171' },
                { bottom: '#14532d', top: '#4ade80' },
                { bottom: '#7c2d12', top: '#fb923c' }
            ];
            
            const scheme = schemes[player.skinIndex];
            return interpolateColor(scheme.bottom, scheme.top, gradientRatio);
        }

        function changeSkin(playerNum, direction) {
            // In online mode, only allow changing your own player's skin
            if (gameMode === 'online') {
                const myPlayerNum = getMyPlayerNum();
                if (myPlayerNum && playerNum !== myPlayerNum) {
                    console.log('Cannot change opponent skin in online mode');
                    return;
                }
            }
            
            const player = players[playerNum];
            player.skinIndex = (player.skinIndex + direction + COLOR_SCHEMES.length) % COLOR_SCHEMES.length;
            updateSkinPreview(playerNum);
            
            // Sync skin change in online mode
            if (gameMode === 'online' && connections.length > 0) {
                console.log('Broadcasting skin change:', playerNum, player.skinIndex);
                broadcastToAll({
                    type: 'skinChange',
                    playerNum: playerNum,
                    skinIndex: player.skinIndex
                });
            }
        }

        function updateSkinPreview(playerNum) {
            const preview = document.getElementById(`skinPreview${playerNum}`);
            const schemes = [
                { bottom: '#1e1b4b', top: '#818cf8' },
                { bottom: '#0c4a6e', top: '#38bdf8' },
                { bottom: '#7f1d1d', top: '#f87171' },
                { bottom: '#14532d', top: '#4ade80' },
                { bottom: '#7c2d12', top: '#fb923c' }
            ];
            
            const scheme = schemes[players[playerNum].skinIndex];
            const gradient = players[playerNum].flipped ? 
                `linear-gradient(to top, ${scheme.bottom}, ${scheme.top})` :
                `linear-gradient(to bottom, ${scheme.bottom}, ${scheme.top})`;
            
            preview.style.background = gradient;
        }

        function showSkinSelector(playerNum) {
            // Just cycle through skins when clicked
            changeSkin(playerNum, 1);
        }

        function collide(player, piece, offsetX, offsetY) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x] !== 0) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        if (newY >= 0 && player.board[newY][newX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge(player) {
            player.piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        const boardY = player.piece.y + y;
                        const boardX = player.piece.x + x;
                        if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                            player.board[boardY][boardX] = value;
                        }
                    }
                });
            });
        }

        function clearLines(player) {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (player.board[y][x] === 0) {
                        continue outer;
                    }
                }
                player.board.splice(y, 1);
                player.board.unshift(Array(COLS).fill(0));
                linesCleared++;
                y++; // Check this row again since we shifted
            }

            if (linesCleared > 0) {
                // Find which player number this is
                let playerNum = null;
                for (let i = 1; i <= 4; i++) {
                    if (players[i] === player) {
                        playerNum = i;
                        break;
                    }
                }
                
                // SNES Tetris scoring
                const points = {
                    1: 40,    // Single
                    2: 100,   // Double
                    3: 300,   // Triple
                    4: 1200   // Tetris!
                };
                player.score += points[linesCleared] || 0;
                
                // Announce Tetris!
                if (linesCleared === 4 && playerNum && gameMode === 'online') {
                    const name = playerNames[player.peerId] || `Player ${playerNum}`;
                    showTetrisAnnouncement(name);
                    // Broadcast tetris announcement
                    broadcastToAll({
                        type: 'tetrisAnnouncement',
                        playerName: name
                    });
                }
                
                // Update the display immediately
                if (playerNum) {
                    updateScore(playerNum);
                }
            }
            return linesCleared;
        }

        function move(player, dir) {
            if (!collide(player, player.piece, dir, 0)) {
                player.piece.x += dir;
            }
        }

        function rotate(player) {
            if (!player || !player.piece) return;
            
            const piece = player.piece;
            const rotated = [];
            for (let y = 0; y < piece.shape.length; y++) {
                rotated.push([]);
                for (let x = 0; x < piece.shape[y].length; x++) {
                    rotated[y][x] = piece.shape[piece.shape.length - 1 - x][y];
                }
            }

            const oldShape = piece.shape;
            piece.shape = rotated;

            let offset = 0;
            let attempts = 0;
            while (collide(player, piece, offset, 0) && attempts < 10) {
                offset = offset > 0 ? -(offset + 1) : -offset;
                if (Math.abs(offset) > piece.shape[0].length) {
                    piece.shape = oldShape;
                    return;
                }
                attempts++;
            }
            
            if (attempts >= 10) {
                piece.shape = oldShape;
                return;
            }
            
            piece.x += offset;
        }

        function drop(player, isSoftDrop = false) {
            if (!player || !player.piece) {
                console.error('Invalid player or piece in drop');
                return false;
            }
            
            if (!collide(player, player.piece, 0, 1)) {
                player.piece.y++;
                
                // Award 1 point for soft drop (when player presses down)
                if (isSoftDrop) {
                    player.score += 1;
                    const playerNum = player === players[1] ? 1 : 2;
                    updateScore(playerNum);
                }
                
                return true;
            } else {
                // Piece has landed
                merge(player);
                clearLines(player);
                player.piece = getNextPiece(player);
                
                if (collide(player, player.piece, 0, 0)) {
                    handlePlayerLoss(player);
                }
                return false;
            }
        }

        function hardDrop(player) {
            if (!player || !player.piece) return;
            
            let maxDrops = 20; // Safety limit
            while (!collide(player, player.piece, 0, 1) && maxDrops > 0) {
                player.piece.y++;
                maxDrops--;
            }
            drop(player, false);
        }

        function handlePlayerLoss(player) {
            player.losses++;
            player.score = Math.max(0, player.score - 1000);
            player.board = createBoard();
            player.nextPieces = [];
            fillNextPiecesQueue(player);
            player.piece = getNextPiece(player);
            
            // Find which player number this is
            let playerNum = null;
            for (let i = 1; i <= 4; i++) {
                if (players[i] === player) {
                    playerNum = i;
                    break;
                }
            }
            
            if (playerNum) {
                updateScore(playerNum);
                showLossNotification(playerNum);
            }
            
            checkGameOver();
        }

        function showLossNotification(playerNum) {
            const playerName = playerNames[players[playerNum].peerId] || `Player ${playerNum}`;
            const lossOverlay = document.createElement('div');
            lossOverlay.className = 'loss-overlay';
            lossOverlay.textContent = `${playerName} Lost!`;
            document.body.appendChild(lossOverlay);
            
            setTimeout(() => {
                document.body.removeChild(lossOverlay);
            }, 2000);
        }

        function checkGameOver() {
            if (maxLosses === 'infinite') return;
            
            // Count how many active players have reached max losses
            let playersStillIn = [];
            for (let i = 1; i <= 4; i++) {
                if (players[i].active && players[i].losses < maxLosses) {
                    playersStillIn.push(i);
                }
            }
            
            // Game ends when only 0 or 1 players remain under max losses
            if (playersStillIn.length <= 1) {
                let winner;
                let finalScoreText = '';
                
                if (playersStillIn.length === 1) {
                    // One winner
                    const winnerNum = playersStillIn[0];
                    winner = playerNames[players[winnerNum].peerId] || `Player ${winnerNum}`;
                } else {
                    // Everyone reached max losses - highest score wins
                    let highestScore = -1;
                    let winnerNum = null;
                    for (let i = 1; i <= 4; i++) {
                        if (players[i].active && players[i].score > highestScore) {
                            highestScore = players[i].score;
                            winnerNum = i;
                        }
                    }
                    winner = winnerNum ? (playerNames[players[winnerNum].peerId] || `Player ${winnerNum}`) : 'Draw';
                }
                
                // Build final scores text
                const scoreLines = [];
                for (let i = 1; i <= 4; i++) {
                    if (players[i].active) {
                        const name = playerNames[players[i].peerId] || `Player ${i}`;
                        scoreLines.push(`${name}: ${players[i].score}`);
                    }
                }
                finalScoreText = scoreLines.join(' | ');
                
                document.getElementById('winnerText').textContent = 
                    winner === 'Draw' ? 'Draw!' : `${winner} Wins!`;
                document.getElementById('finalScores').textContent = finalScoreText;
                
                gameRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                document.getElementById('gameArea').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
        }

        function draw(playerNum) {
            const p = players[playerNum];
            p.ctx.fillStyle = '#000';
            p.ctx.fillRect(0, 0, p.canvas.width, p.canvas.height);

            // Draw board with gradient and glow
            p.board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        const color = getBlockColor(p, value, y);
                        
                        // Glow effect
                        p.ctx.shadowBlur = 15;
                        p.ctx.shadowColor = color;
                        
                        p.ctx.fillStyle = color;
                        p.ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        
                        // Inner highlight
                        p.ctx.shadowBlur = 0;
                        p.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        p.ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
                        
                        // Border
                        p.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        p.ctx.lineWidth = 1;
                        p.ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });

            // Draw current piece with gradient and glow
            if (p.piece) {
                p.piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            const boardY = p.piece.y + y;
                            const color = getBlockColor(p, value, boardY);
                            
                            // Glow effect
                            p.ctx.shadowBlur = 20;
                            p.ctx.shadowColor = color;
                            
                            p.ctx.fillStyle = color;
                            p.ctx.fillRect(
                                (p.piece.x + x) * BLOCK_SIZE,
                                (p.piece.y + y) * BLOCK_SIZE,
                                BLOCK_SIZE,
                                BLOCK_SIZE
                            );
                            
                            // Inner highlight
                            p.ctx.shadowBlur = 0;
                            p.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            p.ctx.fillRect(
                                (p.piece.x + x) * BLOCK_SIZE + 2,
                                (p.piece.y + y) * BLOCK_SIZE + 2,
                                BLOCK_SIZE - 4,
                                BLOCK_SIZE - 4
                            );
                            
                            // Border
                            p.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                            p.ctx.lineWidth = 1;
                            p.ctx.strokeRect(
                                (p.piece.x + x) * BLOCK_SIZE,
                                (p.piece.y + y) * BLOCK_SIZE,
                                BLOCK_SIZE,
                                BLOCK_SIZE
                            );
                        }
                    });
                });
            }
            
            p.ctx.shadowBlur = 0;
            
            // Draw next pieces
            drawNextPieces(playerNum);
        }

        function drawNextPieces(playerNum) {
            const p = players[playerNum];
            
            // In online mode, draw only the first next piece to the bottom canvas
            if (gameMode === 'online') {
                const canvas = document.getElementById(`nextBottom${playerNum}`);
                if (canvas && p.nextPieces[0]) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const piece = p.nextPieces[0];
                    const blockSize = 10;
                    const offsetX = (canvas.width - piece.shape[0].length * blockSize) / 2;
                    const offsetY = (canvas.height - piece.shape.length * blockSize) / 2;
                    
                    piece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value > 0) {
                                const color = getBlockColor(p, value, 10);
                                
                                ctx.shadowBlur = 8;
                                ctx.shadowColor = color;
                                ctx.fillStyle = color;
                                ctx.fillRect(
                                    offsetX + x * blockSize,
                                    offsetY + y * blockSize,
                                    blockSize,
                                    blockSize
                                );
                                
                                ctx.shadowBlur = 0;
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                                ctx.fillRect(
                                    offsetX + x * blockSize + 1,
                                    offsetY + y * blockSize + 1,
                                    blockSize - 2,
                                    blockSize - 2
                                );
                            }
                        });
                    });
                    
                    ctx.shadowBlur = 0;
                }
            } else {
                // Local mode: draw all 5 next pieces on the side
                for (let i = 0; i < 5; i++) {
                    const canvas = document.getElementById(`next${playerNum}-${i}`);
                    if (!canvas) continue;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (p.nextPieces[i]) {
                        const piece = p.nextPieces[i];
                        const blockSize = 10;
                        const offsetX = (canvas.width - piece.shape[0].length * blockSize) / 2;
                        const offsetY = (canvas.height - piece.shape.length * blockSize) / 2;
                        
                        piece.shape.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value > 0) {
                                    const color = getBlockColor(p, value, 10);
                                    
                                    ctx.shadowBlur = 8;
                                    ctx.shadowColor = color;
                                    ctx.fillStyle = color;
                                    ctx.fillRect(
                                        offsetX + x * blockSize,
                                        offsetY + y * blockSize,
                                        blockSize,
                                        blockSize
                                    );
                                    
                                    ctx.shadowBlur = 0;
                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                                    ctx.fillRect(
                                        offsetX + x * blockSize + 1,
                                        offsetY + y * blockSize + 1,
                                        blockSize - 2,
                                        blockSize - 2
                                    );
                                }
                            });
                        });
                        
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }

        function updateScore(playerNum) {
            const p = players[playerNum];
            document.getElementById(`score${playerNum}`).textContent = p.score;
            document.getElementById(`losses${playerNum}`).textContent = p.losses;
        }

        function update(time = 0) {
            if (!gameRunning) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                return;
            }

            try {
                if (gameMode === 'local') {
                    // Update both players in local mode
                    if (players[1] && players[1].piece && players[1].active) {
                        const deltaTime1 = time - players[1].lastTime;
                        players[1].lastTime = time;
                        players[1].dropCounter += deltaTime1;

                        if (players[1].dropCounter > players[1].dropInterval) {
                            drop(players[1], false);
                            players[1].dropCounter = 0;
                        }
                    }

                    if (players[2] && players[2].piece && players[2].active) {
                        const deltaTime2 = time - players[2].lastTime;
                        players[2].lastTime = time;
                        players[2].dropCounter += deltaTime2;

                        if (players[2].dropCounter > players[2].dropInterval) {
                            drop(players[2], false);
                            players[2].dropCounter = 0;
                        }
                    }
                } else if (gameMode === 'online') {
                    // In online mode, only update MY board
                    const myPlayer = getMyPlayer();
                    if (myPlayer && myPlayer.piece) {
                        const deltaTime = time - myPlayer.lastTime;
                        myPlayer.lastTime = time;
                        myPlayer.dropCounter += deltaTime;

                        if (myPlayer.dropCounter > myPlayer.dropInterval) {
                            drop(myPlayer, false);
                            myPlayer.dropCounter = 0;
                        }
                        
                        // Send my state to all other players
                        broadcastMyState();
                    }
                }

                // Draw all active boards
                for (let i = 1; i <= 4; i++) {
                    if (players[i] && players[i].canvas && players[i].active) {
                        draw(i);
                    }
                }
            } catch (e) {
                console.error('Update error:', e);
                gameRunning = false;
            }

            // Continue animation loop
            if (gameRunning) {
                animationId = requestAnimationFrame(update);
            }
        }

        function getMyPlayer() {
            for (let i = 1; i <= 4; i++) {
                if (players[i].peerId === myPlayerId) {
                    return players[i];
                }
            }
            return null;
        }

        function getMyPlayerNum() {
            for (let i = 1; i <= 4; i++) {
                if (players[i].peerId === myPlayerId) {
                    return i;
                }
            }
            return null;
        }

        function broadcastMyState() {
            const myPlayer = getMyPlayer();
            if (!myPlayer || connections.length === 0) return;
            
            const myPlayerNum = getMyPlayerNum();
            const state = {
                type: 'gameState',
                playerNum: myPlayerNum,
                board: myPlayer.board,
                piece: myPlayer.piece,
                score: myPlayer.score,
                losses: myPlayer.losses,
                nextPieces: myPlayer.nextPieces
            };
            
            connections.forEach(conn => {
                if (conn && conn.open) {
                    try {
                        conn.send(state);
                    } catch (e) {
                        console.error('Error sending state:', e);
                    }
                }
            });
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            if (gameMode === 'local') {
                // Player 1 controls: WASD
                if (e.key.toLowerCase() === 'a') {
                    move(players[1], -1);
                } else if (e.key.toLowerCase() === 'd') {
                    move(players[1], 1);
                } else if (e.key.toLowerCase() === 's') {
                    drop(players[1], true);
                } else if (e.key.toLowerCase() === 'w') {
                    rotate(players[1]);
                } else if (e.key.toLowerCase() === 'q') {
                    hardDrop(players[1]);
                }
                
                // Player 2 controls: Arrow keys
                if (e.key === 'ArrowLeft') {
                    move(players[2], -1);
                } else if (e.key === 'ArrowRight') {
                    move(players[2], 1);
                } else if (e.key === 'ArrowDown') {
                    drop(players[2], true);
                } else if (e.key === 'ArrowUp') {
                    rotate(players[2]);
                } else if (e.key === ' ') {
                    hardDrop(players[2]);
                }
            } else if (gameMode === 'online') {
                // In online mode, only control my own player
                const myPlayer = getMyPlayer();
                if (!myPlayer) return;
                
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                    move(myPlayer, -1);
                } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                    move(myPlayer, 1);
                } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                    drop(myPlayer, true);
                } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                    rotate(myPlayer);
                } else if (e.key === ' ' || e.key.toLowerCase() === 'q') {
                    e.preventDefault();
                    hardDrop(myPlayer);
                }
            }
        });

        // Menu functions
        function startLocalGame() {
            gameMode = 'local';
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.remove('hidden');
        }

        function showOnlineMenu() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('onlineMenu').classList.remove('hidden');
        }

        function backToMainMenu() {
            document.getElementById('settingsMenu').classList.add('hidden');
            document.getElementById('menu').classList.remove('hidden');
        }

        function backToMainMenuFromOnline() {
            document.getElementById('onlineMenu').classList.add('hidden');
            document.getElementById('menu').classList.remove('hidden');
        }

        function proceedToGame() {
            const maxLossesValue = document.getElementById('maxLosses').value;
            maxLosses = maxLossesValue === 'infinite' ? 'infinite' : parseInt(maxLossesValue);
            
            // Get player names
            player1Name = document.getElementById('player1NameInput').value.trim() || 'Player 1';
            player2Name = document.getElementById('player2NameInput').value.trim() || 'Player 2';
            
            gameMode = 'local';
            
            // Activate both local players
            players[1].active = true;
            players[2].active = true;
            players[1].peerId = 'local1';
            players[2].peerId = 'local2';
            
            // Deactivate players 3 and 4 (local only supports 2)
            players[3].active = false;
            players[4].active = false;
            
            document.getElementById('settingsMenu').classList.add('hidden');
            document.getElementById('gameArea').classList.remove('hidden');
            
            // Hide boards 3 and 4 in local mode
            updateBoardVisibility();
            
            // Update player name displays
            document.getElementById('playerName1').textContent = player1Name;
            document.getElementById('playerName2').textContent = player2Name;
            
            // Set controls text for local mode
            const controlsText = document.getElementById('controlsText');
            if (controlsText) {
                controlsText.innerHTML = '<strong>Player 1:</strong> WASD (W=rotate, A=left, S=soft drop, D=right, Q=hard drop)<br><strong>Player 2:</strong> Arrow keys (‚Üë=rotate, ‚Üê=left, ‚Üì=soft drop, ‚Üí=right, Space=hard drop)';
            }
            
            initGame();
            gameRunning = true;
            animationId = requestAnimationFrame(update);
        }

        function initGame() {
            // Initialize canvases for all active players
            for (let i = 1; i <= 4; i++) {
                if (players[i].active) {
                    if (!players[i].canvas) {
                        players[i].canvas = document.getElementById(`canvas${i}`);
                        if (players[i].canvas) {
                            players[i].ctx = players[i].canvas.getContext('2d');
                        }
                    }
                    
                    players[i].board = createBoard();
                    players[i].nextPieces = [];
                    fillNextPiecesQueue(players[i]);
                    players[i].piece = getNextPiece(players[i]);
                    players[i].score = 0;
                    players[i].losses = 0;
                    players[i].dropCounter = 0;
                    players[i].lastTime = 0;
                    
                    updateScore(i);
                    updateSkinPreview(i);
                }
            }
        }

        function createLobby() {
            console.log('createLobby called');
            
            // Get player name
            player1Name = document.getElementById('onlinePlayerName').value.trim();
            if (!player1Name) {
                alert('Please enter your name');
                console.log('No name provided');
                return;
            }
            console.log('Host name:', player1Name);
            
            lobbyCode = Math.random().toString(36).substring(2, 8).toUpperCase();
            isHost = true;
            peer = new Peer(lobbyCode);
            console.log('Creating peer with lobby code:', lobbyCode);
            
            peer.on('open', (id) => {
                console.log('Host peer opened with ID:', id);
                myPlayerId = id;
                connectedPlayers = 1;
                
                // Host is always player 1
                players[1].peerId = myPlayerId;
                players[1].active = true;
                playerNames[myPlayerId] = player1Name;
                console.log('Host set as player 1');
                
                document.getElementById('onlineMenu').classList.add('hidden');
                document.getElementById('lobbyWaiting').classList.remove('hidden');
                document.getElementById('lobbyCodeDisplay').textContent = lobbyCode;
                
                updateLobbyStatus();
                console.log('Lobby waiting screen shown');
            });

            peer.on('connection', (connection) => {
                console.log('Incoming connection from peer:', connection.peer);
                
                // Accept connection but don't increment counter yet (will do in playerInfo handler)
                connections.push(connection);
                console.log('Connection accepted, total connections:', connections.length);
                
                setupConnection(connection);
            });

            peer.on('error', (err) => {
                console.error('Host peer error:', err);
                alert('Error creating lobby: ' + err.message);
                backToMainMenuFromOnline();
            });
        }

        function updateLobbyStatus() {
            const statusEl = document.getElementById('lobbyStatus');
            if (statusEl) {
                if (connectedPlayers >= maxPlayers) {
                    statusEl.textContent = `Lobby full (${connectedPlayers}/${maxPlayers} players). Ready up to start!`;
                } else if (connectedPlayers >= 2) {
                    statusEl.textContent = `${connectedPlayers}/${maxPlayers} players connected. Ready to start! (or wait for more)`;
                } else {
                    const minNeeded = 2 - connectedPlayers;
                    statusEl.textContent = `${connectedPlayers}/${maxPlayers} players connected. Need ${minNeeded} more to start.`;
                }
            }
            
            // Auto-show ready screen when we have enough players (minimum 2)
            if (connectedPlayers >= 2 && document.getElementById('lobbyWaiting').classList.contains('hidden') === false) {
                showReadyScreen();
            }
        }

        function updateSpectatorCount(count) {
            const counterEl = document.getElementById('spectatorCount');
            const containerEl = document.getElementById('spectatorCounter');
            if (counterEl && containerEl) {
                counterEl.textContent = count;
                // Show/hide based on count
                if (count > 0) {
                    containerEl.style.display = 'block';
                } else {
                    containerEl.style.display = 'none';
                }
            }
        }

        function joinLobby() {
            console.log('joinLobby called');
            
            // Get player name
            const myName = document.getElementById('onlinePlayerName').value.trim();
            if (!myName) {
                alert('Please enter your name');
                console.log('No name provided');
                return;
            }
            console.log('Name:', myName);
            
            const code = document.getElementById('joinCode').value.toUpperCase().trim();
            if (!code) {
                alert('Please enter a lobby code');
                console.log('No code provided');
                return;
            }
            console.log('Code:', code);

            isHost = false;
            peer = new Peer();
            console.log('Peer created');

            peer.on('open', (id) => {
                console.log('Peer opened with ID:', id);
                myPlayerId = id;
                playerNames[myPlayerId] = myName;
                
                // Show connecting UI immediately
                console.log('Hiding online menu, showing lobby waiting');
                document.getElementById('onlineMenu').classList.add('hidden');
                document.getElementById('lobbyWaiting').classList.remove('hidden');
                document.getElementById('lobbyCodeDisplay').textContent = code;
                const statusEl = document.getElementById('lobbyStatus');
                if (statusEl) {
                    statusEl.textContent = 'Connecting to lobby...';
                }
                
                // Connect to host
                console.log('Attempting to connect to host:', code);
                const conn = peer.connect(code);
                console.log('Connection object created:', conn);
                connections.push(conn);
                
                setupConnection(conn);
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                alert('Error joining lobby: ' + err.message);
                backToMainMenuFromOnline();
            });
        }

        function setupConnection(conn) {
            console.log('setupConnection called for connection:', conn);
            
            conn.on('open', () => {
                console.log('Connection opened! isHost:', isHost);
                
                // Update status for joiners
                if (!isHost) {
                    const statusEl = document.getElementById('lobbyStatus');
                    if (statusEl) {
                        statusEl.textContent = 'Connected! Waiting for game to start...';
                        console.log('Updated status to connected');
                    }
                }
                
                // Send my info to the other player
                console.log('Sending playerInfo:', myPlayerId, playerNames[myPlayerId]);
                conn.send({
                    type: 'playerInfo',
                    peerId: myPlayerId,
                    name: playerNames[myPlayerId]
                });
                
                // If I'm not host, ask for game state
                if (!isHost) {
                    console.log('Requesting game state from host');
                    conn.send({ type: 'requestGameState' });
                }
            });

            conn.on('data', (data) => {
                console.log('Received data:', data);
                try {
                    handleMessage(data, conn);
                } catch (e) {
                    console.error('Error handling message:', e);
                }
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
                alert('Connection error: ' + err.message);
            });

            conn.on('close', () => {
                console.log('Connection closed for peer');
                
                // Remove this connection
                const index = connections.indexOf(conn);
                if (index > -1) {
                    connections.splice(index, 1);
                }
                
                // Find which player/spectator disconnected
                let disconnectedPlayerNum = null;
                let disconnectedName = '';
                let wasSpectator = false;
                
                // Check if it was a player
                for (let i = 1; i <= 4; i++) {
                    if (players[i].active && players[i].peerId && connections.some(c => c.peer === players[i].peerId)) {
                        // This player's connection is still in connections, continue
                    } else if (players[i].active && players[i].peerId) {
                        // This player's connection is NOT in connections - they disconnected
                        const peerId = players[i].peerId;
                        if (playerNames[peerId]) {
                            disconnectedPlayerNum = i;
                            disconnectedName = playerNames[peerId];
                            // Deactivate player
                            players[i].active = false;
                            players[i].peerId = null;
                            connectedPlayers--;
                            console.log(`Player ${i} (${disconnectedName}) disconnected`);
                            break;
                        }
                    }
                }
                
                // Check if it was a spectator
                if (!disconnectedPlayerNum) {
                    for (let i = spectators.length - 1; i >= 0; i--) {
                        if (!connections.some(c => c.peer === spectators[i].peerId)) {
                            disconnectedName = spectators[i].name;
                            spectators.splice(i, 1);
                            wasSpectator = true;
                            console.log(`Spectator ${disconnectedName} disconnected`);
                            break;
                        }
                    }
                }
                
                // Broadcast disconnect
                if (isHost && (disconnectedPlayerNum || wasSpectator)) {
                    // Remove disconnected player from readyPlayers
                    if (disconnectedPlayerNum) {
                        const disconnectedPeerId = Object.keys(playerNames).find(peerId => 
                            playerNames[peerId] === disconnectedName
                        );
                        if (disconnectedPeerId && readyPlayers[disconnectedPeerId] !== undefined) {
                            delete readyPlayers[disconnectedPeerId];
                            console.log('Removed disconnected player from readyPlayers');
                        }
                    }
                    
                    broadcastToAll({
                        type: 'playerDisconnected',
                        playerNum: disconnectedPlayerNum,
                        name: disconnectedName,
                        spectatorCount: spectators.length,
                        wasSpectator: wasSpectator,
                        readyPlayers: readyPlayers  // Include updated readyPlayers
                    });
                    
                    if (wasSpectator) {
                        updateSpectatorCount(spectators.length);
                    } else {
                        updateBoardVisibility();
                        updateReadyDisplay();  // Update ready count
                    }
                }
                
                // End game if a player disconnected during active game
                if (gameMode === 'online' && gameRunning && disconnectedPlayerNum) {
                    alert(`${disconnectedName} disconnected`);
                    // Don't auto-end game, let remaining players continue
                }
            });
        }

        function handleMessage(data, conn) {
            console.log('handleMessage received:', data.type, data);
            
            switch (data.type) {
                case 'playerInfo':
                    console.log('Processing playerInfo');
                    // Store player info
                    playerNames[data.peerId] = data.name;
                    
                    if (isHost) {
                        console.log('Host processing new player');
                        // Try to assign this player a slot (2-4)
                        let assigned = false;
                        for (let i = 2; i <= 4; i++) {
                            if (!players[i].active) {
                                players[i].peerId = data.peerId;
                                players[i].active = true;
                                assigned = true;
                                connectedPlayers++;
                                console.log('Assigned player to slot', i, 'Total players:', connectedPlayers);
                                break;
                            }
                        }
                        
                        if (!assigned) {
                            // All player slots full - make them a spectator
                            console.log('All slots full, making spectator');
                            spectators.push({ peerId: data.peerId, name: data.name });
                            
                            conn.send({
                                type: 'spectatorAssigned',
                                message: 'All player slots full. You are now spectating.'
                            });
                        }
                        
                        // Check if ready screen is already shown
                        const readyScreenShown = document.getElementById('readyScreen').classList.contains('hidden') === false;
                        
                        // Add new player to readyPlayers if ready screen is shown
                        if (readyScreenShown && assigned) {
                            readyPlayers[data.peerId] = false;
                            console.log('Added new player to readyPlayers');
                        }
                        
                        // Send current game state to new player/spectator (now includes them in readyPlayers)
                        console.log('Sending gameStateSync to new player/spectator');
                        conn.send({
                            type: 'gameStateSync',
                            players: getActivePlayers(),
                            playerNames: playerNames,
                            connectedPlayers: connectedPlayers,
                            spectatorCount: spectators.length,
                            readyPlayers: readyPlayers,
                            gameRunning: gameRunning  // Tell joiner if game is already running
                        });
                        
                        // If game is already running and player was assigned, initialize them immediately
                        if (gameRunning && assigned) {
                            // Find which slot they were assigned to
                            let assignedSlot = null;
                            for (let i = 2; i <= 4; i++) {
                                if (players[i].peerId === data.peerId) {
                                    assignedSlot = i;
                                    break;
                                }
                            }
                            
                            if (assignedSlot) {
                                // Initialize the new player's board
                                if (!players[assignedSlot].canvas) {
                                    players[assignedSlot].canvas = document.getElementById(`canvas${assignedSlot}`);
                                    players[assignedSlot].ctx = players[assignedSlot].canvas.getContext('2d');
                                }
                                players[assignedSlot].board = createBoard();
                                players[assignedSlot].nextPieces = [];
                                fillNextPiecesQueue(players[assignedSlot]);
                                players[assignedSlot].piece = getNextPiece(players[assignedSlot]);
                                players[assignedSlot].score = 0;
                                players[assignedSlot].losses = 0;
                                players[assignedSlot].dropCounter = 0;
                                players[assignedSlot].lastTime = performance.now();
                                updateScore(assignedSlot);
                                updateSkinPreview(assignedSlot);
                                
                                // Update board visibility for all players
                                updateBoardVisibility();
                                
                                // Broadcast board visibility update
                                broadcastToAll({
                                    type: 'updateVisibility'
                                });
                            }
                        }
                        
                        // Broadcast to all OTHER players that a new player/spectator joined
                        broadcastToAll({
                            type: assigned ? 'playerJoined' : 'spectatorJoined',
                            peerId: data.peerId,
                            name: data.name,
                            spectatorCount: spectators.length,
                            readyPlayers: readyPlayers  // Include updated readyPlayers so everyone syncs
                        });
                        
                        updateLobbyStatus();
                        
                        // Show ready screen if enough players and not already shown
                        if (connectedPlayers >= 2 && !readyScreenShown) {
                            console.log('Showing ready screen for host');
                            showReadyScreen();
                        } else if (readyScreenShown && assigned) {
                            // Update display with new player count
                            updateReadyDisplay();
                        }
                    }
                    break;
                    
                case 'gameStateSync':
                    console.log('Received gameStateSync');
                    // Received full game state from host
                    Object.entries(data.players).forEach(([num, playerData]) => {
                        players[num].peerId = playerData.peerId;
                        players[num].active = playerData.active;
                        if (playerData.skinIndex !== undefined) {
                            players[num].skinIndex = playerData.skinIndex;
                            updateSkinPreview(num);
                        }
                        console.log('Synced player', num, playerData);
                    });
                    Object.assign(playerNames, data.playerNames);
                    connectedPlayers = data.connectedPlayers || 0;
                    console.log('Total connected players:', connectedPlayers);
                    
                    // Sync spectator count
                    if (data.spectatorCount !== undefined) {
                        updateSpectatorCount(data.spectatorCount);
                    }
                    
                    // Sync ready state
                    if (data.readyPlayers) {
                        readyPlayers = data.readyPlayers;
                    }
                    
                    // Check if game is already running (late join)
                    if (data.gameRunning) {
                        console.log('Late joining - game already running');
                        // Hide lobby/ready screens, show game
                        document.getElementById('lobbyWaiting').classList.add('hidden');
                        document.getElementById('readyScreen').classList.add('hidden');
                        const gameArea = document.getElementById('gameArea');
                        gameArea.classList.remove('hidden');
                        gameArea.classList.add('online-mode');
                        
                        // Update board visibility
                        updateBoardVisibility();
                        
                        // Start game for this client
                        gameMode = 'online';
                        gameRunning = true;
                        
                        // Initialize my player
                        const myPlayerNum = getMyPlayerNum();
                        if (myPlayerNum && players[myPlayerNum].active) {
                            if (!players[myPlayerNum].canvas) {
                                players[myPlayerNum].canvas = document.getElementById(`canvas${myPlayerNum}`);
                                players[myPlayerNum].ctx = players[myPlayerNum].canvas.getContext('2d');
                            }
                            players[myPlayerNum].board = createBoard();
                            players[myPlayerNum].nextPieces = [];
                            fillNextPiecesQueue(players[myPlayerNum]);
                            players[myPlayerNum].piece = getNextPiece(players[myPlayerNum]);
                            players[myPlayerNum].score = 0;
                            players[myPlayerNum].losses = 0;
                            players[myPlayerNum].dropCounter = 0;
                            players[myPlayerNum].lastTime = performance.now();
                            updateScore(myPlayerNum);
                            updateSkinPreview(myPlayerNum);
                            
                            const name = playerNames[players[myPlayerNum].peerId] || `Player ${myPlayerNum}`;
                            document.getElementById(`playerName${myPlayerNum}`).textContent = name;
                        }
                        
                        // Update spectator count
                        updateSpectatorCount(data.spectatorCount || 0);
                        
                        // Start the game loop
                        animationId = requestAnimationFrame(update);
                    } else {
                        // Normal join - transition to ready screen
                        console.log('Transitioning to ready screen');
                        document.getElementById('lobbyWaiting').classList.add('hidden');
                        showReadyScreen();
                    }
                    break;
                    
                case 'lobbyFull':
                    alert('Lobby is full (maximum 4 players)');
                    endGame();
                    break;
                    
                case 'playerJoined':
                    playerNames[data.peerId] = data.name;
                    
                    // Sync readyPlayers from host (includes new player)
                    if (data.readyPlayers) {
                        readyPlayers = data.readyPlayers;
                        
                        // Update my button state
                        const readyButton = document.getElementById('readyButton');
                        if (readyButton && myPlayerId) {
                            const isReady = readyPlayers[myPlayerId] || false;
                            readyButton.textContent = isReady ? 'Cancel Ready' : 'Ready Up!';
                            readyButton.style.background = isReady ? '#10b981' : '#6366f1';
                        }
                        
                        updateReadyDisplay();
                    }
                    
                    updateLobbyStatus();
                    break;
                    
                case 'spectatorJoined':
                    playerNames[data.peerId] = data.name;
                    updateSpectatorCount(data.spectatorCount);
                    break;
                    
                case 'spectatorAssigned':
                    // I am now a spectator
                    alert(data.message);
                    // Transition to spectator view (still show lobby/ready/game but can't interact)
                    break;
                    
                case 'playerDisconnected':
                    console.log('Player disconnected:', data.name);
                    
                    // Sync readyPlayers from host
                    if (data.readyPlayers) {
                        readyPlayers = data.readyPlayers;
                    }
                    
                    if (data.wasSpectator) {
                        updateSpectatorCount(data.spectatorCount);
                    } else if (data.playerNum) {
                        // Deactivate the disconnected player
                        players[data.playerNum].active = false;
                        players[data.playerNum].peerId = null;
                        connectedPlayers--;
                        updateBoardVisibility();
                        updateReadyDisplay();
                    }
                    break;
                    
                case 'ready':
                    readyPlayers[data.peerId] = data.ready;
                    updateReadyDisplay();
                    checkAllReady();
                    break;
                    
                case 'syncReadyState':
                    // Host is syncing the ready state for all players
                    readyPlayers = data.readyPlayers;
                    
                    // Update my ready button state
                    const readyButton = document.getElementById('readyButton');
                    if (readyButton && myPlayerId) {
                        const isReady = readyPlayers[myPlayerId] || false;
                        readyButton.textContent = isReady ? 'Cancel Ready' : 'Ready Up!';
                        readyButton.style.background = isReady ? '#10b981' : '#6366f1';
                    }
                    
                    updateReadyDisplay();
                    break;
                    
                case 'startGame':
                    startOnlineGame();
                    break;
                    
                case 'gameState':
                    // Update remote player's state
                    if (data.playerNum && players[data.playerNum]) {
                        players[data.playerNum].board = data.board;
                        players[data.playerNum].piece = data.piece;
                        players[data.playerNum].score = data.score;
                        players[data.playerNum].losses = data.losses;
                        players[data.playerNum].nextPieces = data.nextPieces;
                        updateScore(data.playerNum);
                    }
                    break;
                    
                case 'skinChange':
                    console.log('Received skin change:', data.playerNum, data.skinIndex);
                    if (data.playerNum && players[data.playerNum]) {
                        players[data.playerNum].skinIndex = data.skinIndex;
                        updateSkinPreview(data.playerNum);
                    }
                    break;
                    
                case 'tetrisAnnouncement':
                    showTetrisAnnouncement(data.playerName);
                    break;
                    
                case 'updateVisibility':
                    updateBoardVisibility();
                    break;
            }
        }

        function getActivePlayers() {
            const active = {};
            for (let i = 1; i <= 4; i++) {
                if (players[i].active) {
                    active[i] = {
                        peerId: players[i].peerId,
                        active: players[i].active,
                        skinIndex: players[i].skinIndex
                    };
                }
            }
            return active;
        }

        function broadcastToAll(message) {
            connections.forEach(conn => {
                if (conn && conn.open) {
                    try {
                        conn.send(message);
                    } catch (e) {
                        console.error('Error broadcasting:', e);
                    }
                }
            });
        }

        function showReadyScreen() {
            document.getElementById('lobbyWaiting').classList.add('hidden');
            document.getElementById('readyScreen').classList.remove('hidden');
            
            if (isHost) {
                // Host initializes ready states for all active players
                readyPlayers = {};
                for (let i = 1; i <= 4; i++) {
                    if (players[i].active) {
                        readyPlayers[players[i].peerId] = false;
                    }
                }
                
                // Broadcast ready state to all clients
                broadcastToAll({
                    type: 'syncReadyState',
                    readyPlayers: readyPlayers
                });
            }
            // Non-hosts already have readyPlayers from gameStateSync or syncReadyState
            
            // Reset my ready button to default state
            const readyButton = document.getElementById('readyButton');
            if (readyButton && myPlayerId) {
                const isReady = readyPlayers[myPlayerId] || false;
                readyButton.textContent = isReady ? 'Cancel Ready' : 'Ready Up!';
                readyButton.style.background = isReady ? '#10b981' : '#6366f1';
            }
            
            updateReadyDisplay();
        }

        function updateReadyDisplay() {
            let readyCount = 0;
            let totalPlayers = 0;
            
            for (let peerId in readyPlayers) {
                totalPlayers++;
                if (readyPlayers[peerId]) readyCount++;
            }
            
            document.getElementById('p1ReadyStatus').textContent = `${readyCount}/${totalPlayers} players ready`;
            
            if (readyCount === totalPlayers && totalPlayers >= 2) {
                document.getElementById('p2ReadyStatus').textContent = 'All players ready! Starting soon...';
                document.getElementById('p2ReadyStatus').style.color = '#10b981';
            } else {
                document.getElementById('p2ReadyStatus').textContent = 'Waiting for all players to ready up...';
                document.getElementById('p2ReadyStatus').style.color = 'rgba(255, 255, 255, 0.6)';
            }
        }

        function checkAllReady() {
            let allReady = true;
            let playerCount = 0;
            
            for (let peerId in readyPlayers) {
                playerCount++;
                if (!readyPlayers[peerId]) {
                    allReady = false;
                }
            }
            
            if (allReady && playerCount >= 2 && isHost) {
                // Host tells everyone to start
                broadcastToAll({ type: 'startGame' });
                setTimeout(() => startOnlineGame(), 500);
            }
        }

        function toggleReady() {
            const currentlyReady = readyPlayers[myPlayerId] || false;
            readyPlayers[myPlayerId] = !currentlyReady;
            
            // Update button
            const readyButton = document.getElementById('readyButton');
            readyButton.textContent = readyPlayers[myPlayerId] ? 'Cancel Ready' : 'Ready Up!';
            readyButton.style.background = readyPlayers[myPlayerId] ? '#10b981' : '#6366f1';
            
            // Broadcast my ready state
            broadcastToAll({
                type: 'ready',
                peerId: myPlayerId,
                ready: readyPlayers[myPlayerId]
            });
            
            updateReadyDisplay();
            checkAllReady();
        }

        function startOnlineGame() {
            gameMode = 'online';
            gameRunning = true;
            
            document.getElementById('readyScreen').classList.add('hidden');
            const gameArea = document.getElementById('gameArea');
            gameArea.classList.remove('hidden');
            gameArea.classList.add('online-mode');  // Add class to switch to bottom next pieces
            
            // Show/hide player boards based on how many are active
            updateBoardVisibility();
            
            // Initialize all active players
            initGame();
            
            // Update player names for all active players
            for (let i = 1; i <= 4; i++) {
                if (players[i].active) {
                    const name = playerNames[players[i].peerId] || `Player ${i}`;
                    document.getElementById(`playerName${i}`).textContent = name;
                }
            }
            
            // Update spectator count
            updateSpectatorCount(spectators.length);
            
            // Update controls text for online mode
            const controlsText = document.getElementById('controlsText');
            if (controlsText) {
                controlsText.innerHTML = '<strong>Online Mode:</strong> All players use WASD or Arrow keys (W/‚Üë=rotate, A/‚Üê=left, S/‚Üì=soft drop, D/‚Üí=right, Q/Space=hard drop)';
            }
            
            // Disable all opponent's skin controls in online mode
            const myPlayerNum = getMyPlayerNum();
            if (myPlayerNum) {
                for (let i = 1; i <= 4; i++) {
                    if (i !== myPlayerNum && players[i].active) {
                        // Disable this opponent's skin carousel
                        const carouselButtons = document.querySelectorAll(`.player-area:nth-child(${i}) .skin-arrow`);
                        carouselButtons.forEach(btn => {
                            btn.disabled = true;
                            btn.style.opacity = '0.3';
                            btn.style.cursor = 'not-allowed';
                        });
                    }
                }
            }
            
            animationId = requestAnimationFrame(update);
        }
        
        function updateBoardVisibility() {
            const player3Area = document.querySelector('.player-area-3');
            const player4Area = document.querySelector('.player-area-4');
            
            if (gameMode === 'local') {
                // Local mode: ALWAYS hide players 3 and 4
                if (player3Area) player3Area.classList.add('hidden');
                if (player4Area) player4Area.classList.add('hidden');
            } else if (gameMode === 'online') {
                // Online mode: Show/hide based on active players
                if (player3Area) {
                    if (players[3].active) {
                        player3Area.classList.remove('hidden');
                    } else {
                        player3Area.classList.add('hidden');
                    }
                }
                
                if (player4Area) {
                    if (players[4].active) {
                        player4Area.classList.remove('hidden');
                    } else {
                        player4Area.classList.add('hidden');
                    }
                }
            }
        }

        function cancelLobby() {
            if (peer) peer.destroy();
            connections.forEach(conn => {
                if (conn) conn.close();
            });
            connections = [];
            readyPlayers = {};
            playerNames = {};
            connectedPlayers = 0;
            
            document.getElementById('lobbyWaiting').classList.add('hidden');
            document.getElementById('readyScreen').classList.add('hidden');
            backToMainMenuFromOnline();
        }

        function showTetrisAnnouncement(playerName) {
            const announcement = document.getElementById('tetrisAnnouncement');
            const nameEl = document.getElementById('tetrisPlayerName');
            if (announcement && nameEl) {
                nameEl.textContent = playerName;
                announcement.style.display = 'block';
                // Hide after 2 seconds
                setTimeout(() => {
                    announcement.style.display = 'none';
                }, 2000);
            }
        }

        function endGame() {
            gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            connections.forEach(conn => {
                if (conn) conn.close();
            });
            if (peer) peer.destroy();
            
            connections = [];
            peer = null;
            readyPlayers = {};
            playerNames = {};
            player1Name = 'Player 1';
            player2Name = 'Player 2';
            connectedPlayers = 0;
            myPlayerId = null;
            spectators = [];  // Clear spectators
            
            // Deactivate all players
            for (let i = 1; i <= 4; i++) {
                players[i].active = false;
                players[i].peerId = null;
            }
            
            // Clear input fields
            document.getElementById('player1NameInput').value = '';
            document.getElementById('player2NameInput').value = '';
            document.getElementById('onlinePlayerName').value = '';
            document.getElementById('joinCode').value = '';
            
            const gameArea = document.getElementById('gameArea');
            gameArea.classList.add('hidden');
            gameArea.classList.remove('online-mode');  // Remove online-mode class
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('readyScreen').classList.add('hidden');
            document.getElementById('lobbyWaiting').classList.add('hidden');
            document.getElementById('menu').classList.remove('hidden');
            
            // Hide spectator counter
            updateSpectatorCount(0);
        }
    </script>
</body>
</html>
